<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MinIO介绍与FastDFS对比</title>
      <link href="/2023/02/28/MinIO%E4%BB%8B%E7%BB%8D%E4%B8%8EFastDFS%E5%AF%B9%E6%AF%94/"/>
      <url>/2023/02/28/MinIO%E4%BB%8B%E7%BB%8D%E4%B8%8EFastDFS%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="分布式文件系统概念"><a href="#分布式文件系统概念" class="headerlink" title="分布式文件系统概念"></a>分布式文件系统概念</h3><p>分布式文件系统具有冗余性，大量数据分散到不同的节点上存储。部分节点的故障并不影响整体的正常运行，而且即使出现故障的计算机存储的数据已经损坏，也可以由其它节点将损坏的数据恢复出来，大大减小了数据丢失的风险。</p><p>衡量分布式文件系统的劣势</p><ul><li>数据的存储方式：无论采取何种存储方式，目的都是为了保证数据的存储安全和方便获取。</li><li>数据的读取速率：包括响应用户读取数据文件的请求、定位数据文件所在的节点、读取实际硬盘中数据文件的时间、不同节点间的数据传输时间以及一部分处理器的处理时间等。</li></ul><h3 id="MinIO-特点"><a href="#MinIO-特点" class="headerlink" title="MinIO 特点"></a>MinIO 特点</h3><ol><li>高性能：作为高性能对象存储，在标准硬件条件下它能达到55GB&#x2F;s的读、35GG&#x2F;s的写速率</li><li>可扩容：不同MinIO集群可以组成联邦，并形成一个全局的命名空间，并跨越多个数据中心</li><li>SDK支持: 基于Minio轻量的特点，它得到类似Java、Python或Go等语言的sdk支持</li><li>支持纠删码：MinIO使用纠删码、Checksum来防止硬件错误和静默数据污染。在最高冗余度配置下，即使丢失1&#x2F;2的磁盘也能恢复数据</li></ol><h4 id="安装部署（运维简单）"><a href="#安装部署（运维简单）" class="headerlink" title="安装部署（运维简单）"></a>安装部署（运维简单）</h4><ul><li>MinIO在安装过程是黑盒的，不用深入关注它的架构，也不需要进行零件组装，基本上可以做到开箱即用。普通的技术人员就能够参与后期的运维。</li><li>MinIO提供了两种部署方式：单机部署和分布式，两种部署方式都非常简单，其中分布式部署还提供了纠删码功能来降低数据丢失的风险。</li></ul><h4 id="开放全部源代码-企业级支持"><a href="#开放全部源代码-企业级支持" class="headerlink" title="开放全部源代码 + 企业级支持"></a>开放全部源代码 + 企业级支持</h4><p>MinIO 基于Apache V2 license 100%开放源代码。这就意味着 MinIO的客户能够自动的、无限制、自由免费使用和集成MinIO、自由的创新和创造、自由的去修改、自由的再次发行新的版本和软件。确实, MinIO 强有力的支持和驱动了很多世界500强的企业。此外，其部署的多样性和专业性提供了其他软件无法比拟的优势。</p><h4 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h4><p>MinIO自带UI界面，且页面不需要你单独的部署，和服务端一并安装，开箱即用。</p><h4 id="容器化支持"><a href="#容器化支持" class="headerlink" title="容器化支持"></a>容器化支持</h4><p>MinIO 符合一切原生云计算的架构和构建过程，并且包含最新的云计算的全新的技术和概念。其中包括支持Kubernetes 、Docker、微服和多租户的的容器技术。</p><p><img src="https://img-blog.csdnimg.cn/c1f3eecfbac84d4684ec26d3db320262.png#pic_center" alt="在这里插入图片描述"></p><h4 id="丰富的SDK支持"><a href="#丰富的SDK支持" class="headerlink" title="丰富的SDK支持"></a>丰富的SDK支持</h4><p>MinIO几乎提供了所有主流开发语言的SDK以及文档。</p><p><img src="https://img-blog.csdnimg.cn/da7b81b0e36343d9b38427bf048d5284.png#pic_center" alt="在这里插入图片描述"></p><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>MinIO 是全球领先的<a href="https://so.csdn.net/so/search?q=%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8&spm=1001.2101.3001.7020">对象存储</a>先锋，目前在全世界有数百万的用户。在标准硬件上，读&#x2F;写速度上高达183 GB &#x2F; 秒 和 171 GB &#x2F; 秒。<br>对象存储可以充当主存储层，以处理Spark、Presto、TensorFlow、H2O.ai等各种复杂工作负载以及成为Hadoop HDFS的替代品。<br>MinIO用作云原生应用程序的主要存储，与传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。而这些都是MinIO能够达成的性能指标。</p><p><img src="https://img-blog.csdnimg.cn/e0ddb219924a4f4980398a29639de507.png#pic_center" alt="在这里插入图片描述"></p><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>MinIO利用了Web缩放器的来之不易的知识，为对象存储带来了简单的缩放模型。这是我们坚定的理念 “简单可扩展” 在 MinIO，扩展从单个群集开始，该群集可以与其他MinIO群集联合以创建全局名称空间, 并在需要时可以跨越多个不同的数据中心。通过添加更多集群可以扩展名称空间，更多机架，直到实现目标。</p><h4 id="纠删码-erasure-code-模式"><a href="#纠删码-erasure-code-模式" class="headerlink" title="纠删码(erasure code)模式"></a>纠删码(erasure code)模式</h4><p>MinIO 使用纠删码和校验和等特性保护数据免受硬件故障和静默数据损坏。使用最高级别的冗余，使用者可最多丢失多达一半（N&#x2F;2）的驱动器，仍可以自动恢复数据。</p><h3 id="MinIO-与-FastDFS-对比"><a href="#MinIO-与-FastDFS-对比" class="headerlink" title="MinIO 与[[FastDFS]] 对比"></a>MinIO 与[[FastDFS]] 对比</h3><ol><li>安装部署(运维)</li></ol><ul><li>FastDFS安装部署(运维)复杂。</li><li>MinIO在安装的过程是黑盒的，你不用去深入关注它的架构，也不需要你进行零件组装，基本上可以做到开箱即用。普通的技术人员就能够参与后期运维。</li></ul><ol start="2"><li>文档</li></ol><ul><li>FastDFS没有官方文档</li><li>MinIO有官方网站，并且有详细的文档</li></ul><ol start="3"><li>开源项目运营组织</li></ol><ul><li>FastDFS是阿里余庆做的一个个人项目，在一些互联网创业公司中有应用，没有官网，不活跃。目前已经很少做更新。</li><li>MinIO目前是由2014年在硅谷创立的公司MinIO.Inc运营的开源项目，社区论坛的活跃度目前也非常的不错。</li></ul><ol start="4"><li>UI界面</li></ol><ul><li>FastDFS默认是不带UI界面的。</li><li>MinIO的界面不需要你单独的部署，和服务端一并安装，开箱即用。</li></ul><ol start="5"><li>性能</li></ol><ul><li>MinIO号称是世界上速度最快的对象存储服务器。在标准硬件上，对象存储的读&#x2F;写速度最高可以达到183 GB&#x2F;s和171 GB&#x2F;s。</li><li>FastDFS很难达到MinIO“号称的”以G为单位的每秒读写速度。</li></ul><ol start="6"><li>容器化支持</li></ol><ul><li>MinIO提供了与k8s、etcd、docker等容器化技术深度集成方案，可以说就是为了云环境而生的。</li><li>FastDFS不具备。</li></ul><ol start="7"><li>丰富的SDK支持</li></ol><ul><li>FastDFS目前提供了 C 和 Java SDK，以及 PHP 扩展 SDK。</li><li>MinIO几乎提供了所有主流开发语言的SDK以及文档。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Support service component </category>
          
          <category> Distributed file storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> minio </tag>
            
            <tag> fastdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cargo国内被墙导致失败解决办法</title>
      <link href="/2023/02/28/cargo%E5%9B%BD%E5%86%85%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2023/02/28/cargo%E5%9B%BD%E5%86%85%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="打开cargo-配置文件"><a href="#打开cargo-配置文件" class="headerlink" title="打开cargo 配置文件"></a>打开cargo 配置文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi ~/.cargo/config<br></code></pre></td></tr></table></figure><h1 id="替换文中内容"><a href="#替换文中内容" class="headerlink" title="替换文中内容"></a>替换文中内容</h1><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># 放到 `$HOME/.cargo/config` 文件中</span><br><span class="hljs-section">[source.crates-io]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 替换成你偏好的镜像源</span><br><span class="hljs-attr">replace-with</span> = <span class="hljs-string">&#x27;sjtu&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;ustc&#x27;</span><br><br><span class="hljs-comment"># 清华大学</span><br><span class="hljs-section">[source.tuna]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><br><span class="hljs-comment"># 中国科学技术大学</span><br><span class="hljs-section">[source.ustc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 上海交通大学</span><br><span class="hljs-section">[source.sjtu]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><br><span class="hljs-comment"># rustcc社区</span><br><span class="hljs-section">[source.rustcc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><br><span class="hljs-section">[net]</span><br><span class="hljs-attr">git-fetch-with-cli</span>=<span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming Language </category>
          
          <category> Rust language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> 编程环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7大程序设计原则</title>
      <link href="/2023/02/25/7%E5%A4%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2023/02/25/7%E5%A4%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>编程的工作既是技术活，也是体力活，而编写优秀的软件，更是一件比较难的事情。</p><p>初级程序员只希望代码不出错，顶级程序员却把写代码当成艺术，当年雷军以过人的能力成为求伯君的左膀右臂，其早年的代码被说成“像诗一样优美”。</p><p>很多大牛，在着手写代码时并不是直接上手编写，而是根据需求进行设计，不但将代码中 Bug 出现的机率降到最低，还让代码具有高可读性，高安全性等等。</p><p>那大牛们都遵循怎样的原则呢，我们能不能学习一下？</p><p>将大牛们的经验总结到一起，可以得到以下「7 大程序设计原则」 。这些设计原理源于对实际软件开发现场的分析，是提高代码质量的经验结晶。</p><p>让我们一起一探究竟吧！</p><h1 id="01-简单性原则"><a href="#01-简单性原则" class="headerlink" title="01 简单性原则"></a>01 简单性原则</h1><p>Simplicity Principle</p><p>What：追求简单<br>简单性原则就是追求简单。</p><p>说得极端一点，就是自始至终都以最简单的逻辑编写代码，让编程初学者一眼就能看懂。</p><p>因此，在编程时我们要重视的是局部的完整性，而不是复杂的整体关联性。</p><p>Why：Bug 喜欢出现在复杂的地方<br>软件故障常集中在某一个区域，而这些区域都有一个共同的特点，那就是复杂。编写代码时如果追求简单易懂，代码就很难出现问题。</p><p>不过，简单易懂的代码往往给人一种不够专业的感觉。这也是经验老到的程序员喜欢写老练高深的代码的原因。所以我们要有足够的定力来抵挡这种诱惑。</p><p>Do：编写自然的代码<br>努力写出自然的代码。放下高超的技巧，坚持用简单的逻辑编写代码。</p><p>既然故障集中在代码复杂的区域，那我们只要让代码简单到让故障无处可藏即可。不要盲目地让代码复杂化、臃肿化，要保证代码简洁。</p><h1 id="02-同构原则"><a href="#02-同构原则" class="headerlink" title="02 同构原则"></a>02 同构原则</h1><p>Isomorphism Principle</p><p>What：力求规范<br>同构原则就是力求规范。</p><p>同等对待相同的东西，坚持不搞特殊。同等对待，举例来说就 是同一个模块管理的数值全部采用同一单位、公有函数的参数个数统一等。</p><p>Why：不同的东西会更显眼<br>相同的东西用相同的形式表现能够使不同的东西更加突出。不同的 东西往往容易产生 bug。遵循同构原则能让我们更容易嗅出代码的异样， 从而找出问题所在。</p><p>图表和工业制品在设计上追求平衡之美，在这一点上，同构原则也 有着相似之处。统一的代码颇具美感，而美的东西一般更容易让人接 受，因此统一的代码有较高的可读性。</p><p>Do：编写符合规范的代码<br>我们要让代码符合一定的规范。不过，这会与程序员的自我表现欲相冲突。</p><p>为了展现自己的实力，有些程序员会无视编程规范，编写独特的代码。可靠与简单是代码不可或缺的性质，但这些程序员常常在无意间让代码变得复杂。</p><p>这就把智慧与个性用错了地方。小小的自我满足远不及代码质量重要。所以在编写代码时，务必克制住自己的表现欲，以规范为先。</p><h1 id="03-对称原则"><a href="#03-对称原则" class="headerlink" title="03 对称原则"></a>03 对称原则</h1><p>Symmetry Principle</p><p>What：讲究形式上的对称<br>讲究形式上的对称。</p><p>对称原则就是讲究形式上的对称，比如有上就有下，有左就有右， 有主动就有被动。</p><p>也就是说，我们在思考一个处理时，也要想到与之成对的处理。比 如有给标志位置 1 的处理，就要有给标志位置 0 的处理。</p><p>Why：帮助读代码的人推测后面的代码<br>具有对称性的代码能够帮助读代码的人推测后面的代码，提高其理解代码的速度。同时，对称性会给代码带来美感，这同样有助于他人理解代码。</p><p>此外，设计代码时将对称性纳入考虑的范围能防止我们在思考问题时出现遗漏。如果说代码的条件分支是故障的温床，那么对称性就是思考的框架，能有效阻止条件遗漏。</p><p>Do：编写有对称性的代码<br>在出现“条件”的时候，我们要注意它的“反条件”。每个控制条件都存在与之成对的反条件(与指示条件相反的条件)。要注意条件与反条件的统一，保证控制条件具有统一性。</p><p>我们还要考虑到例外情况并极力避免其发生。例外情况的特殊性会破坏对称性，成为故障的温床。特殊情况过多意味着需求没有得到整理。此时应重新审视需求，尽量从代码中剔除例外情况。</p><p>命名也要讲究对称性。命名时建议使用 set&#x2F;get、start&#x2F;stop、begin&#x2F; end 和 push&#x2F;pop 等成对的词语。</p><h1 id="04-层次原则"><a href="#04-层次原则" class="headerlink" title="04 层次原则"></a>04 层次原则</h1><p>Hierarchy Principle</p><p>What：讲究层次<br>注意事物的主从关系、前后关系和本末关系等层次关系，整理事物的关联性。</p><p>不同层次各司其职，同种处理不跨越多个层次，这一点非常重要。比如执行了获取资源的处理，那么释放资源的处理就要在相同的层次进行。又比如互斥控制的标志位置 1 和置 0 的处理要在同一层次进行。</p><p>Why：层次结构有助于提高代码的可读性<br>有明确层次结构的代码能帮助读代码的人抽象理解代码的整体结构。读代码的人可以根据自身需要阅读下一层次的代码，掌握更加详细的信息。</p><p>这样一来就可以提高代码的可读性，帮助程序员表达编码意图，降低 bug 发生的概率。</p><p>Do：编写有抽象层次结构的代码<br>在编写代码时设计各部分的抽象程度，构建层次结构。保证同一个层次中的所有代码抽象程度相同。另外，高层次的代码要通过外部视角描述低层次的代码。这样做能让调用低层次代码的高层次代码更加简单易懂。</p><h1 id="05-线性原则"><a href="#05-线性原则" class="headerlink" title="05 线性原则"></a>05 线性原则</h1><p>Linearity Principle</p><p>What：处理流程尽量走直线<br>线性原则就是让处理流程尽量走直线。</p><p>一个功能如果可以通过多个功能的线性结合来实现，那它的结构就会非常简单。</p><p>反过来，用条件分支控制代码、毫无章法地增加状态数等行为会让代码变得难以理解。我们要避免做出这些行为，提高代码的可读性。</p><p>Why：直线处理可提高代码的可读性<br>复杂的处理流程是故障的温床。</p><p>故障多出现在复杂的条件语句和循环语句中。另外，goto 等让流程出现跳跃的语句也是故障的多发地。</p><p>如果能让处理由高层次流向低层次，一气呵成，代码的可读性就会大幅提高。与此同时，可维护性也将提高，添加功能等改良工作将变得更加容易。</p><p>一般来说，自上而下的处理流程简单明快，易于理解。我们应避开复杂反复的处理流程。</p><p>Do：尽量不在代码中使用条件分支<br>尽量减少条件分支的数量，编写能让代码阅读者线性地看完整个处理流程的代码。</p><p>为此，我们需要把一些特殊的处理拿到主处理之外。保证处理的统一性，注意处理的流程。记得时不时俯瞰代码整体，检查代码是否存在过于复杂的部分。</p><p>另外，对于经过长期维护而变得过于复杂的部分，我们可以考虑对其进行重构。明确且可靠的设计不仅对我们自身有益，还可以给负责维护的人带来方便。</p><h1 id="06-清晰原则"><a href="#06-清晰原则" class="headerlink" title="06 清晰原则"></a>06 清晰原则</h1><p>Clarity Principle</p><p>What：注意逻辑的清晰性<br>清晰原则就是注意逻辑的清晰性。</p><p>逻辑具有清晰性就代表逻辑能清楚证明自身的正确性。也就是说，我们编写的代码要让人一眼就能判断出没有问题。任何不明确的部分都 要附有说明。</p><p>保证逻辑的清晰性要“不择手段”。在无法用代码证明逻辑正确性的情况下，我们也可以通过写注释、附文档或画图等方法来证明。不过，证明逻辑的正确性是一件麻烦的事，时间一长，人们就会懒得用辅助手段去证明，转而编写逻辑清晰的代码了。</p><p>Why：消除不确定性<br>代码免不了被人一遍又一遍地阅读，所以代码必须保持较高的可读性。编写代码时如果追求高可读性，我们就不会采用取巧的方式编写代码，编写出的代码会非常自然。</p><p>采用取巧的方式编写的代码除了能让计算机运行以外没有任何意义。代码是给人看的，也是由人来修改的，所以我们必须以人为对象来编写代码。</p><p>消除代码的不确定性是对自己的作品负责，这么做也可以为后续负责维护的人提供方便。</p><p>Do：编写逻辑清晰的代码<br>我们要编写逻辑清晰的代码。</p><p>为此，我们应选用直观易懂的逻辑。会给读代码的人带来疑问的部分要么消除，要么加以注释。</p><p>另外，我们应使用任何人都能立刻理解且不存在歧义的术语。要特别注意变量名等一定不能没有意义。</p><h1 id="07-安全原则"><a href="#07-安全原则" class="headerlink" title="07 安全原则"></a>07 安全原则</h1><p>Safty Principle</p><p>What：注意安全性<br>安全原则就是注意安全性，采用相对安全的方法来对具有不确定性的、模糊的部分进行设计和编程。</p><p>说得具体一点，就是在编写代码时刻意将不可能的条件考虑进去。比如即便某个 i f 语句一定成立，我们也要考虑 else 语句的情况；即便某个 case 语句一定成立，我们也要考虑 default 语句的情况；即便某个变量不可能为空，我们也要检查该变量是否为 NULL。</p><p>Why：防止故障发展成重大事故<br>硬件提供的服务必须保证安全，软件也一样。</p><p>硬件方面，比如取暖器，为防止倾倒起火，取暖器一般会配有倾倒自动断电装置。同样，设计软件时也需要考虑各种情况，保证软件在各种情况下都能安全地运行。这一做法在持续运营服务和防止数据损坏等方面有着积极的意义。</p><p>Do：编写安全的代码<br>选择相对安全的方法对具有不确定性的部分进行设计。列出所有可能的运行情况，确保软件在每种情况下都能安全运行。理解需求和功能，将各种情况正确分解到代码中，这样能有效提高软件安全运行的概率。</p><p>为此，我们也要将不可能的条件视为考察对象，对其进行设计和编程。不过，为了统一标准，我们在编写代码前最好规定哪些条件需要写，哪些条件不需要写。</p>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
          <category> 软件设计思想（Program Design） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design </tag>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计与架构关注问题</title>
      <link href="/2023/02/25/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%85%B3%E6%B3%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2023/02/25/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%85%B3%E6%B3%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="从产品到研发"><a href="#从产品到研发" class="headerlink" title="从产品到研发"></a>从产品到研发</h2><p><img src="/2023/02/25/系统设计与架构关注问题/aaa.png"></p><h2 id="常规业务系统设计关键-领域模型"><a href="#常规业务系统设计关键-领域模型" class="headerlink" title="常规业务系统设计关键-领域模型"></a>常规业务系统设计关键-领域模型</h2><p>业务系统设计的关键是在于如何定义系统的模型以及模型之间的关系，其中主要是领域模型的定义，当我们在模型确定之后，模型之间的关系也会随之明确。模型设计可以参考领域模型的经典书籍《Domain-Driven Design》一书，通过这个基本可以对领域定义、防腐层、贫血模型等概念有一个较为清晰的认识了。单个应用内的领域模型系统也需要注意领域分层，作为开发大家是不是见过、重构过很多Controller-Service-DAO 样式的代码分层设计？往往在在做重构的时候会令人吐血。</p><p>设计较好的领域设计这里给一个分层建议：</p><ul><li>接口层 Interface：主要负责与外部系统进行交互&amp;通信，比如一些 dubbo服务、Restful API、RMI等，这一层主要包括 Facade、DTO还有一些Assembler。</li><li>应用层 Application：这一层包含的主要组件就是 Service 服务，但是要特别注意，这一层的Service不是简单的DAO层的包装，在领域驱动设计的架构里面，Service层只是一层很“薄”的一层，它内部并不实现任何逻辑，只是负责协调和转发、委派业务动作给更下层的领域层。</li><li>领域层 Domain：Domain 层是领域模型系统的核心，负责维护面向对象的领域模型，几乎全部的业务逻辑都会在这一层实现。内部主要包含Entity（实体）、ValueObject（值对象）、Domain Event（领域事件）和 Repository（仓储）等多种重要的领域组件。</li><li>基础设施层 Infrastructure：它主要为 Interfaces、Application 和 Domain 三层提供支撑。所有与具体平台、框架相关的实现会在 Infrastructure 中提供，避免三层特别是 Domain 层掺杂进这些实现，从而“污染”领域模型。Infrastructure 中最常见的一类设施是对象持久化的具体实现。</li></ul><h2 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h2><p>在面试中是不是经常被问到一个问题：如果你系统的流量增加 N 倍你要怎么重新设计你的系统？这个高并发的问题可以从各个层面去解，比如</p><p>代码层面：</p><ul><li>锁优化（采用无锁数据结构），主要是 concurrent 包下面的关于 AQS 锁的一些内容</li><li>数据库缓存设计（降低数据库并发争抢压力），这里又会有缓存、DB 数据不一致的问题，在实际使用中，高并发系统和数据一致性系统采用的策略会截然相反。</li><li>数据更新时采用合并更新，可以在应用层去做更新合并，同一个 Container 在同一时间只会有一个 DB 更新请求。</li><li>其他的比如基于 BloomFilter 的空间换时间、通过异步化降低处理时间、通过多线程并发执行等等。</li></ul><p>数据库层面：</p><ul><li>根据不同的存储诉求来进行不同的存储选型，从早期的 RDBMS，再到 NoSql（KV存储、文档数据库、全文索引引擎等等），再到最新的NewSql（TiDB、Google spanner&#x2F;F1 DB）等等。</li><li>表数据结构的设计，字段类型选择与区别。</li><li>索引设计，需要关注聚簇索引原理与覆盖索引消除排序等，至于最左匹配原则都是烂大街的常识了，高级一点索引消除排序的一些机制等等，B+树与B树的区别。</li><li>最后的常规手段：分库分表、读写分离、数据分片、热点数据拆分等等，高并发往往会做数据分桶，这里面往深了去说又有很多，比如分桶如何初始化、路由规则、最后阶段怎么把数据合并等等，比较经典的方式就是把桶分成一个主桶+N个分桶。</li></ul><p>架构设计层面：</p><ul><li>分布式系统为服务化</li><li>无状态化支持水平弹性扩缩容</li><li>业务逻辑层面 failfast 快速失败</li><li>调用链路热点数据前置</li><li>多级缓存设计</li><li>提前容量规划等等</li></ul><h2 id="高可用系统设计"><a href="#高可用系统设计" class="headerlink" title="高可用系统设计"></a>高可用系统设计</h2><p>对于可用性要求非常高的系统，一般我们都说几个9的可用率，比如 99.999% 等。面对高可用系统设计也可以从各个方面来进行分析</p><p>代码层面：需要关注分布式事务问题，CAP理论是面试的常规套路软件层面：应用支持无状态化，部署的多个模块完全对等，请求在任意模块处理结果完全一致 &#x3D;&gt; 模块不存储上下文信息，只根据请求携带的参数进行处理。目的是为了快速伸缩，服务冗余。常见的比如session问题等。负载均衡问题：软件部署多份之后，如何保证系统负载？如何选择调用机器？也就是负载均衡问题</p><ul><li>狭义上的负载均衡按照类型可以分为这几种：</li><li>硬件负载：比如F5等</li><li>软件负载：比如 LVS、Ngnix、HaProxy、DNS等。</li><li>代码算法上的负载均衡，比如Random、RoundRobin、ConsistentHash、加权轮训等等算法</li><li>广义上的负载均衡可以理解为负载均衡的能力，比如一个负载均衡系统需要如下4个能力：<ul><li>故障机器自动发现</li><li>故障服务自动摘除（服务熔断）</li><li>请求自动重试</li><li>服务恢复自动发现</li></ul></li></ul><h2 id="幂等设计问题"><a href="#幂等设计问题" class="headerlink" title="幂等设计问题"></a>幂等设计问题</h2><p>上面提负载均衡的时候，广义负载均衡需要完成自动重试机制，那么在业务上，我们就必须保证幂等设计。这里可以从2个层面来进行考虑：</p><ul><li>请求层面：由于请求会重试所以必须做幂等，需要保证请求重复执行和执行一次的结果完全相同。请求层面的幂等设计需要在数据修改的层做幂等，也就是数据访问层读请求天然幂等，写请求需要做幂等。读请求一般是天然幂等的，无论查询多少次返回的结果都是一致。这其中的本质实际上是分布式事务问题，这里下面再详细介绍。</li><li>业务层面：不幂等会造成诸如奖励多发、重复下单等非常严重的问题。业务层面的幂等本质上是分布式锁的问题，后面会介绍。如何保证不重复下单？这里比如token机制等等。如何保证商品不超卖？比如乐观锁等。MQ消费方如何保证幂等等都是面试的常见题。</li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>业务层面的幂等设计本质上是分布式锁问题，什么是分布式锁？分布式环境下锁的全局唯一资源，使请求串行化，实际表现互斥锁，解决业务层幂等问题。常见的解决方式是基于 Redis 缓存的 setnx 方法，但作为技术人员应该清楚这其中还存在单点问题、基于超时时间无法续租问题、异步主从同步问题等等，更深一点，CAP理论，一个AP系统本质上无法实现一个AP需求，即使是 RedLock 也不行。那我们如何去设计一个分布式锁呢？强一致性、服务本身要高可用是最基本的需求，其他的比如支持自动续期，自动释放机制，高度抽象接入简单，可视化、可管理等。基于存储层的可靠的解决方案比如</p><ul><li>zookeeper：CP&#x2F;ZAB&#x2F;N+1可用：基于临时节点实现和Watch机制。</li><li>ETCD：CP or AP&#x2F;Raft&#x2F;N+1可用：基于 restful API；KV存储，强一致性，高可用，数据可靠：持久化；Client TTL 模式，需要心跳CAS 唯一凭证 uuid。</li></ul><h2 id="服务的熔断"><a href="#服务的熔断" class="headerlink" title="服务的熔断"></a>服务的熔断</h2><p>微服务化之后，系统分布式部署，系统之间通过 RPC 通讯，整个系统发生故障的概率随着系统规模的增长而增长，一个小的故障经过链路传导放大，有可能造成更大的故障。希望在调用服务的时，在一些非关键路径服务发生服务质量下降的情况下，选择尽可能地屏蔽所造成的影响。大部分熔断返回默认值 null，也可以定制，RPCClient 原生支持最好，业务方少改代码（熔断放的地方），进入熔断时，打印熔断日志，同时返回 Exception（业务方定制熔断方法），需要有服务治理平台，可以看到服务的状态、是否降级、是否熔断、可以实时下发阀值配置等。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>服务整体负载超出预设的上限，或者即将到来的流量预计将会超过阀值，为了保证重要或者基本的服务能够正常运行，拒绝部分请求或者将一些不重要的不紧急的服务或任务进行服务的延迟使用或暂停使用</p><p>主要的手段如下：</p><ul><li>服务层降级，主要手段：</li><li>拒绝部分请求（限流），比如缓存请求队列，拒绝部分等待时间长的请求；根据Head，来拒绝非核心请求；还有其他通用算法上的限流比如令牌桶、漏桶算法等等。</li><li>关闭部分服务：比如双11大促0点会关闭逆向退款服务等等。</li><li>分级降级：比如自治式服务降级，从网关到业务到DB根据拦截、业务规则逐渐降低下游请求量，体现上是从上到下的处理能力逐渐下降。</li><li>数据层降级</li><li>比如流量大的时候，更新请求只缓存到MQ，读请求读缓存，等流量小的时候，进行补齐操作(一般数据访问层如果做了降级，就没必要在数据层再做了)</li><li>柔性可用策略</li><li>比如一些指定最大流量的限流工具，又或是根据CPU负载的限流工具等，需要保证自动打开，不依赖于人工。</li></ul><h2 id="发布方式引发的可用性问题"><a href="#发布方式引发的可用性问题" class="headerlink" title="发布方式引发的可用性问题"></a>发布方式引发的可用性问题</h2><p>发布方式也是影响高可用的一个点，哈哈，以前还经历过一些线上直接停机发布的案例（银行内部系统），不过作为高大上的互联网，主要会采用这几种发布方式：灰度发布、蓝绿发布、金丝雀发布等等。</p><h2 id="数据一致性系统设计"><a href="#数据一致性系统设计" class="headerlink" title="数据一致性系统设计"></a>数据一致性系统设计</h2><p>一般一些金融、账务系统对这一块要求会非常严格，下面主要介绍下这里面涉及到的事务一致性、一致性算法等内容。</p><h2 id="事务一致性问题"><a href="#事务一致性问题" class="headerlink" title="事务一致性问题"></a>事务一致性问题</h2><p>在 DB 层面，一般通过 刚性事务 来实现数据一致性，主要通过 预写日志(WAL) 的方式来实现，WAL(write ahead logging)预写日志的方式。就是所有对数据文件的修改，必须要先写日志，这样，即使在写数据的时候崩溃了，也能通过日志文件恢复，传统的数据库事务就是基于这一个机制（REDO 已提交事务的数据也求改 UNDO 未提交事务的回滚）。</p><p>除了这个方式之外，还有一个就是通过 影子数据块 来进行数据备份，提前记录被修改的数据块的修改前的状态，备份起来，如果需要回滚，直接用这个备份的数据块进行覆盖就好了。其他的就是基于二阶段提交的 XA模型 了。但是目前互联网系统，已经广泛采用分布式部署模式了，传统的刚性事务无法实现，所以 柔性事务成了目前主流的分布式事务解决防范，主要的模式有下面几种：</p><p>TCC 模式&#x2F;或者叫2阶段模式：在 try 阶段预扣除资源（但是不锁定资源，提升可用性），在Confirm 或者 Cancel 阶段进行数据提交或者回滚。一般需要引入协调者，或者叫事务管理器。SAGA模式：业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，支持向前或者向后补偿。MQ的事务消息：就是先发 halfMsg，在处理完之后，再发送 commit 或者 rollback Msg，然后 MQ 会定期询问 producer ，halfMsg 能不能 commit 或者 rollback，最终实现事务的最终一致性。实际上是把补偿的动作委托给了 RocketMQ。分段事物（异步确保）：基于可靠消息+本地事务消息表 + 消息队列重试机制。目前这也是一些大厂的主流方案，内部一般称为分段事物。柔性事务基本都是基于最终一致性去实现，所以肯定会有 补偿 动作在里面，在达到最终一致性之前，对用户一般展示 软状态。</p><p>需要注意的一点是，并不是所有的系统都适合引入数据一致性框架，比如用户可以随时修改自己发起的请求的情况，例如，商家设置后台系统，商户会随时修改数据，这里如果涉及到一致性的话，引入一致性框架会导致补偿动作达到最终一致性之前，资源锁会阻塞用户后续的请求。导致体验较差。这种情况下就需要通过其他手段来保障数据一致性了，比如数据对账等操作。</p><h2 id="一致性算法"><a href="#一致性算法" class="headerlink" title="一致性算法"></a>一致性算法</h2><p>从早期的 Paxos 算法，再到后面衍生的 zab 协议（参考：A simple totally ordered broadcast protocol），提供了当下可靠的分布式锁的解决方案。再到后来的 Raft 算法（In Search of an Understandable Consensus Algorithm），也都是分布式系统设计里面需要了解到的一些知识要点。</p>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
          <category> 软件设计思想（Program Design） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design </tag>
            
            <tag> architecture </tag>
            
            <tag> product </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[<p>title: 404<br>date: 2019-08-5 16:41:10<br>type: “404”<br>layout: “404”<br>description: “Oops～，我崩溃了！找不到你想要的页面 :(“</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<p>layout: categories</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<p>layout: tags</p>]]></content>
      
    </entry>
    
    
  
</search>
